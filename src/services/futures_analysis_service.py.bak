# coding: utf-8
"""
Futures Analysis Service

–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ò–ò-–¥–≤–∏–∂–æ–∫ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ñ—å—é—á–µ—Ä—Å–Ω—ã—Ö –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤ –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
—Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤ —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏ —É—Ä–æ–≤–Ω—è–º–∏ –≤—Ö–æ–¥–∞/–≤—ã—Ö–æ–¥–∞.

–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ —Ç—Ä–µ–π–¥–∏–Ω–≥–∞ —á–µ—Ä–µ–∑ API endpoint.

–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
- 2-3 —Å—Ü–µ–Ω–∞—Ä–∏—è (bullish/bearish/neutral) —Å confidence scoring
- –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —É—Ä–æ–≤–Ω–∏: entry, stop-loss, targets (TP1, TP2, TP3)
- RR calculation, leverage recommendations
- Structured reasoning (–ø–æ—á–µ–º—É —ç—Ç–æ—Ç —Å—Ü–µ–Ω–∞—Ä–∏–π –≤–∞–ª–∏–¥–Ω—ã–π)
- Market context (trend, phase, sentiment, volatility)
"""
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime, timedelta
import json
import pandas as pd
import numpy as np

from loguru import logger

from src.services.binance_service import BinanceService
from src.services.technical_indicators import TechnicalIndicators
from src.services.candlestick_patterns import CandlestickPatterns
from src.services.price_levels_service import PriceLevelsService
from src.services.coingecko_service import CoinGeckoService
from src.services.fear_greed_service import FearGreedService
from src.services.session_detector import session_detector
from src.services.volume_analyzer import volume_analyzer
from src.services.openai_service import OpenAIService


class FuturesAnalysisService:
    """
    –ì–ª–∞–≤–Ω—ã–π –¥–≤–∏–∂–æ–∫ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ñ—å—é—á–µ—Ä—Å–æ–≤ –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤

    –ê–ª–≥–æ—Ä–∏—Ç–º:
    1. –°–æ–±—Ä–∞—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ (price, volume, funding, OI, liquidations, indicators)
    2. –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å market context (trend, phase, sentiment)
    3. –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å 2-3 —Å—Ü–µ–Ω–∞—Ä–∏—è —Å confidence scoring
    4. –í–µ—Ä–Ω—É—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π JSON –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏
    """

    def __init__(self):
        """Initialize services"""
        self.binance = BinanceService()
        self.technical = TechnicalIndicators()
        self.patterns = CandlestickPatterns()
        self.price_levels = PriceLevelsService()
        self.coingecko = CoinGeckoService()
        self.fear_greed = FearGreedService()
        self.openai = OpenAIService()

        logger.info("FuturesAnalysisService initialized")

    async def analyze_symbol(
        self,
        symbol: str,
        timeframe: str = "4h",
        max_scenarios: int = 3
    ) -> Dict[str, Any]:
        """
        –ü–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Ñ—å—é—á–µ—Ä—Å–Ω–æ–≥–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞ —Å –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤

        Args:
            symbol: Trading pair (e.g., 'BTCUSDT')
            timeframe: Primary timeframe for analysis ('1h', '4h', '1d')
            max_scenarios: Maximum number of scenarios to generate (2-3)

        Returns:
            –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π JSON —Å–æ —Å—Ü–µ–Ω–∞—Ä–∏—è–º–∏ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏

        Example output:
            {
                "symbol": "BTCUSDT",
                "analysis_timestamp": "2025-01-15T12:00:00Z",
                "current_price": 95234.5,
                "market_context": {...},
                "scenarios": [...],
                "key_levels": {...},
                "data_quality": {...}
            }
        """
        try:
            logger.info(f"Starting futures analysis for {symbol} on {timeframe}")

            # ====================================================================
            # 1. –°–ë–û–† –î–ê–ù–ù–´–•
            # ====================================================================

            # 1.1 –ü–æ–ª—É—á–∏—Ç—å current price
            current_price = await self.binance.get_current_price(symbol)
            if not current_price:
                return {
                    "success": False,
                    "error": f"Failed to fetch current price for {symbol}"
                }

            # 1.2 –ü–æ–ª—É—á–∏—Ç—å OHLCV –¥–∞–Ω–Ω—ã–µ (200 —Å–≤–µ—á–µ–π –¥–ª—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤)
            klines_df = await self.binance.get_klines(
                symbol=symbol,
                interval=timeframe,
                limit=200
            )

            if klines_df is None or len(klines_df) < 50:
                return {
                    "success": False,
                    "error": f"Insufficient candlestick data for {symbol}"
                }

            # 1.3 –ü–æ–ª—É—á–∏—Ç—å multi-timeframe –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
            mtf_data = await self._get_multi_timeframe_data(symbol)

            # 1.4 –ü–æ–ª—É—á–∏—Ç—å funding rate
            funding_data = await self.binance.get_latest_funding_rate(symbol)

            # 1.5 –ü–æ–ª—É—á–∏—Ç—å Open Interest
            oi_data = await self.binance.get_open_interest(symbol)

            # 1.6 –ü–æ–ª—É—á–∏—Ç—å Long/Short ratio
            ls_ratio = await self.binance.get_long_short_ratio(
                symbol=symbol,
                period="5m",
                limit=30
            )

            # 1.7 –ü–æ–ª—É—á–∏—Ç—å liquidation history (–µ—Å–ª–∏ API keys –µ—Å—Ç—å)
            liquidation_data = None
            if self.binance.has_credentials:
                # üîß FIX: –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º time range –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞
                import time
                end_time = int(time.time() * 1000)
                # –î–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤ - —Ä–∞–∑–Ω—ã–π time range (–Ω–æ max 7 –¥–Ω–µ–π)
                if timeframe in ["1d", "1w"]:
                    days = 7  # 7 –¥–Ω–µ–π –¥–ª—è –±–æ–ª—å—à–∏—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤
                elif timeframe in ["4h", "6h", "8h", "12h"]:
                    days = 5  # 5 –¥–Ω–µ–π –¥–ª—è —Å—Ä–µ–¥–Ω–∏—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤
                else:
                    days = 3  # 3 –¥–Ω—è –¥–ª—è –º–∞–ª—ã—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤ (1h, 15m, etc)

                start_time = end_time - (days * 24 * 60 * 60 * 1000)

                liquidation_data = await self.binance.get_liquidation_history(
                    symbol=symbol,
                    start_time=start_time,
                    end_time=end_time,
                    limit=1000
                )

            # 1.8 –ü–æ–ª—É—á–∏—Ç—å Fear & Greed Index
            fear_greed = await self.fear_greed.get_current()

            # ====================================================================
            # 2. –†–ê–°–ß–Å–¢ –ò–ù–î–ò–ö–ê–¢–û–†–û–í
            # ====================================================================

            indicators = self.technical.calculate_all_indicators(klines_df)
            candlestick_patterns = self.patterns.detect_all_patterns(klines_df)

            # ====================================================================
            # 3. MARKET CONTEXT ANALYSIS
            # ====================================================================

            market_context = self._analyze_market_context(
                price=current_price,
                klines=klines_df,
                indicators=indicators,
                funding=funding_data,
                oi=oi_data,
                ls_ratio=ls_ratio,
                fear_greed=fear_greed,
                mtf_data=mtf_data
            )

            # ====================================================================
            # 4. KEY LEVELS CALCULATION
            # ====================================================================

            key_levels = await self._calculate_key_levels(
                symbol=symbol,
                current_price=current_price,
                klines=klines_df,
                indicators=indicators
            )

            # ====================================================================
            # 5. SCENARIO GENERATION
            # ====================================================================

            scenarios = await self._generate_scenarios(
                symbol=symbol,
                current_price=current_price,
                market_context=market_context,
                indicators=indicators,
                key_levels=key_levels,
                funding=funding_data,
                ls_ratio=ls_ratio,
                liquidation_data=liquidation_data,
                patterns=candlestick_patterns,
                max_scenarios=max_scenarios
            )

            # ====================================================================
            # 6. DATA QUALITY ASSESSMENT
            # ====================================================================

            data_quality = self._assess_data_quality(
                klines=klines_df,
                indicators=indicators,
                funding=funding_data,
                oi=oi_data,
                liquidation_data=liquidation_data
            )

            # ====================================================================
            # 7. FINAL RESULT
            # ====================================================================

            result = {
                "success": True,
                "symbol": symbol,
                "timeframe": timeframe,
                "analysis_timestamp": datetime.utcnow().isoformat() + "Z",
                "current_price": round(current_price, 2),
                "market_context": market_context,
                "scenarios": scenarios,
                "key_levels": key_levels,
                "data_quality": data_quality,
                "metadata": {
                    "has_liquidation_data": liquidation_data is not None,
                    "funding_available": funding_data is not None,
                    "candles_analyzed": len(klines_df),
                    "timeframes_analyzed": list(mtf_data.keys()) if mtf_data else []
                }
            }

            logger.info(
                f"Analysis complete for {symbol}: "
                f"{len(scenarios)} scenarios, "
                f"quality={data_quality['completeness']}%"
            )

            return result

        except Exception as e:
            logger.exception(f"Error in futures analysis for {symbol}: {e}")
            return {
                "success": False,
                "error": str(e),
                "symbol": symbol
            }

    async def _get_multi_timeframe_data(
        self,
        symbol: str
    ) -> Dict[str, pd.DataFrame]:
        """
        –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞

        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è:
        - –ú–∞–∫—Ä–æ-—Ç—Ä–µ–Ω–¥–∞ (1D, 1W)
        - –°—Ä–µ–¥–Ω–µ—Å—Ä–æ—á–Ω–æ–≥–æ —Ç—Ä–µ–Ω–¥–∞ (4H)
        - –ú–∏–∫—Ä–æ-—Å—Ç—Ä—É–∫—Ç—É—Ä—ã (1H)
        """
        mtf_data = {}
        timeframes = ["1h", "4h", "1d"]

        for tf in timeframes:
            try:
                df = await self.binance.get_klines(
                    symbol=symbol,
                    interval=tf,
                    limit=100
                )
                if df is not None and len(df) >= 20:
                    mtf_data[tf] = df
            except Exception as e:
                logger.warning(f"Failed to fetch {tf} data for {symbol}: {e}")

        return mtf_data

    def _analyze_market_context(
        self,
        price: float,
        klines: pd.DataFrame,
        indicators: Dict,
        funding: Optional[Dict],
        oi: Optional[Dict],
        ls_ratio: Optional[Dict],
        fear_greed: Optional[Dict],
        mtf_data: Dict[str, pd.DataFrame]
    ) -> Dict[str, Any]:
        """
        –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–µ–∫—É—â–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ä—ã–Ω–∫–∞

        Returns:
            {
                "trend": "bullish" | "bearish" | "sideways",
                "phase": "continuation" | "reversal" | "accumulation" | "distribution",
                "sentiment": "extreme_greed" | "greed" | "neutral" | "fear" | "extreme_fear",
                "volatility": "very_low" | "low" | "medium" | "high" | "very_high",
                "bias": "long" | "short" | "neutral",
                "strength": 0.0 - 1.0
            }
        """
        context = {}

        # === TREND DETECTION ===
        ema_20 = indicators.get("ema_20")
        ema_50 = indicators.get("ema_50")
        sma_200 = indicators.get("sma_200")

        if ema_20 and ema_50:
            if price > ema_20 > ema_50:
                context["trend"] = "bullish"
                trend_strength = 0.7
            elif price < ema_20 < ema_50:
                context["trend"] = "bearish"
                trend_strength = 0.7
            else:
                context["trend"] = "sideways"
                trend_strength = 0.3
        else:
            context["trend"] = "unknown"
            trend_strength = 0.5

        # === PHASE DETECTION ===
        rsi = indicators.get("rsi", 50)
        adx = indicators.get("adx", 20)

        if adx and adx > 25:
            # Strong trend
            if rsi > 70:
                context["phase"] = "distribution"  # Overbought in uptrend
            elif rsi < 30:
                context["phase"] = "accumulation"  # Oversold in downtrend
            else:
                context["phase"] = "continuation"  # Trend continues
        else:
            # Weak trend / range
            if rsi > 60:
                context["phase"] = "distribution"
            elif rsi < 40:
                context["phase"] = "accumulation"
            else:
                context["phase"] = "consolidation"

        # === SENTIMENT (Fear & Greed) ===
        if fear_greed:
            fg_value = fear_greed.get("value", 50)
            if fg_value >= 75:
                context["sentiment"] = "extreme_greed"
            elif fg_value >= 60:
                context["sentiment"] = "greed"
            elif fg_value >= 40:
                context["sentiment"] = "neutral"
            elif fg_value >= 25:
                context["sentiment"] = "fear"
            else:
                context["sentiment"] = "extreme_fear"
        else:
            context["sentiment"] = "unknown"

        # === VOLATILITY ===
        atr_pct = indicators.get("atr_percent", 2.0)
        context["volatility"] = indicators.get("volatility", "medium")

        # === BIAS CALCULATION (ÁªºÂêàÂà§Êñ≠) ===
        bias_score = 0

        # Trend bias
        if context["trend"] == "bullish":
            bias_score += 2
        elif context["trend"] == "bearish":
            bias_score -= 2

        # RSI bias
        if rsi and rsi < 30:
            bias_score += 1  # Oversold = bullish bias
        elif rsi and rsi > 70:
            bias_score -= 1  # Overbought = bearish bias

        # Funding bias (contrarian)
        if funding:
            funding_rate = funding.get("funding_rate_pct", 0)
            if funding_rate > 0.05:  # High positive funding
                bias_score -= 1  # Too many longs = bearish bias
            elif funding_rate < -0.05:  # High negative funding
                bias_score += 1  # Too many shorts = bullish bias

        # Long/Short ratio bias (contrarian)
        if ls_ratio:
            ratio = ls_ratio.get("long_short_ratio", 1.0)
            if ratio > 2.0:  # Too many longs
                bias_score -= 1
            elif ratio < 0.5:  # Too many shorts
                bias_score += 1

        # Determine final bias
        if bias_score >= 2:
            context["bias"] = "long"
            context["strength"] = min(abs(bias_score) / 5.0, 1.0)
        elif bias_score <= -2:
            context["bias"] = "short"
            context["strength"] = min(abs(bias_score) / 5.0, 1.0)
        else:
            context["bias"] = "neutral"
            context["strength"] = 0.3

        # === ADDITIONAL CONTEXT ===
        context["rsi"] = round(rsi, 1) if rsi else None
        context["funding_rate_pct"] = round(funding.get("funding_rate_pct", 0), 4) if funding else None
        context["long_short_ratio"] = round(ls_ratio.get("long_short_ratio", 1.0), 2) if ls_ratio else None

        # === SESSION DETECTION (NEW!) ===
        session_info = session_detector.get_current_session()
        context["session"] = {
            "current": session_info["session_name"],
            "is_overlap": session_info["is_overlap"],
            "volatility_expected": session_info["volatility_expected"],
            "recommendation": session_detector.get_session_recommendation(session_info)
        }

        # === VOLUME ANALYSIS (NEW!) ===
        volume_analysis = volume_analyzer.analyze(klines)
        if volume_analysis:
            context["volume"] = {
                "relative_volume": volume_analysis.get("relative_volume", 1.0),
                "classification": volume_analysis.get("volume_classification", "normal"),
                "trend": volume_analysis.get("volume_trend", "stable"),
                "spike": volume_analysis.get("volume_spike", False)
            }

        return context

    async def _calculate_key_levels(
        self,
        symbol: str,
        current_price: float,
        klines: pd.DataFrame,
        indicators: Dict
    ) -> Dict[str, Any]:
        """
        –†–∞—Å—Å—á–∏—Ç–∞—Ç—å –∫–ª—é—á–µ–≤—ã–µ —É—Ä–æ–≤–Ω–∏ –¥–ª—è —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤

        Returns:
            {
                "support": [price1, price2, price3],
                "resistance": [price1, price2, price3],
                "ema_levels": {...},
                "vwap": price,
                "liquidation_clusters": {...}
            }
        """
        levels = {}

        # Support/Resistance from OHLC
        ohlc_data = klines[['high', 'low', 'close', 'volume']].to_dict('records')
        sr_data = self.price_levels.calculate_support_resistance_from_ohlc(
            ohlc_data=ohlc_data,
            current_price=current_price,
            lookback_periods=90
        )

        if sr_data.get("success"):
            levels["support"] = sr_data.get("support_levels", [])[:3]
            levels["resistance"] = sr_data.get("resistance_levels", [])[:3]
        else:
            levels["support"] = []
            levels["resistance"] = []

        # EMA levels
        ema_levels = {}
        for ema_type in ["ema_20", "ema_50", "ema_200"]:
            ema_value = indicators.get(ema_type)
            if ema_value:
                ema_levels[ema_type] = {
                    "price": round(ema_value, 2),
                    "distance_pct": round(((current_price - ema_value) / current_price) * 100, 2)
                }
        levels["ema_levels"] = ema_levels

        # VWAP
        vwap = indicators.get("vwap")
        if vwap:
            levels["vwap"] = {
                "price": round(vwap, 2),
                "distance_pct": round(((current_price - vwap) / current_price) * 100, 2)
            }

        # Bollinger Bands
        bb_upper = indicators.get("bb_upper")
        bb_lower = indicators.get("bb_lower")
        if bb_upper and bb_lower:
            levels["bollinger_bands"] = {
                "upper": round(bb_upper, 2),
                "lower": round(bb_lower, 2)
            }

        return levels

    async def _generate_scenarios(
        self,
        symbol: str,
        current_price: float,
        market_context: Dict,
        indicators: Dict,
        key_levels: Dict,
        funding: Optional[Dict],
        ls_ratio: Optional[Dict],
        liquidation_data: Optional[Dict],
        patterns: Dict,
        max_scenarios: int = 3
    ) -> List[Dict[str, Any]]:
        """
        ü§ñ AI-DRIVEN: LLM –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–æ—Ä–≥–æ–≤—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ —Å –∞–Ω–∞–ª–∏–∑–æ–º –ø–æ–ª–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞

        –í–º–µ—Å—Ç–æ rule-based —Ñ–æ—Ä–º—É–ª (entry = price * 1.015), LLM:
        - –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –í–°–ï –¥–∞–Ω–Ω—ã–µ (indicators, patterns, funding, levels)
        - –°–æ–∑–¥–∞–µ—Ç —Å—Ü–µ–Ω–∞—Ä–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ S/R levels –∏ market context
        - –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç entry zones, stop losses, targets
        - –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ —Å —É—á–µ—Ç–æ–º –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏–π
        - –û–±—ä—è—Å–Ω—è–µ—Ç reasoning –∫–∞–∂–¥–æ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è

        Returns:
            List of AI-generated scenarios sorted by confidence
        """
        logger.info("ü§ñ Generating scenarios with AI (not rule-based formulas)...")

        try:
            scenarios = await self._ai_generate_scenarios(
                symbol=symbol,
                current_price=current_price,
                market_context=market_context,
                indicators=indicators,
                key_levels=key_levels,
                patterns=patterns,
                funding=funding,
                ls_ratio=ls_ratio,
                max_scenarios=max_scenarios
            )

            logger.info(f"‚úÖ AI generated {len(scenarios)} scenarios")
            return scenarios

        except Exception as e:
            logger.error(f"‚ùå AI scenario generation failed: {e}")
            raise RuntimeError(f"Failed to generate AI scenarios: {e}")

    async def _ai_generate_scenarios(
        self,
        symbol: str,
        current_price: float,
        market_context: Dict,
        indicators: Dict,
        key_levels: Dict,
        patterns: Optional[Dict],
        funding: Optional[Dict],
        ls_ratio: Optional[Dict],
        max_scenarios: int = 3
    ) -> List[Dict]:
        """
        ü§ñ **MAIN AI ENGINE**: LLM –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Ä—ã–Ω–æ–∫ –∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–æ—Ä–≥–æ–≤—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏

        –ü–û–õ–ù–û–°–¢–¨–Æ AI-DRIVEN –ø–æ–¥—Ö–æ–¥:
        - –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –í–°–ï –¥–∞–Ω–Ω—ã–µ –≤ LLM
        - LLM —Å–∞–º —Ä–µ—à–∞–µ—Ç –∫–∞–∫–∏–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ —Å–æ–∑–¥–∞—Ç—å
        - LLM –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç entry/stop/targets –Ω–∞ –æ—Å–Ω–æ–≤–µ S/R analysis
        - LLM —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ —Å —É—á–µ—Ç–æ–º –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏–π
        - LLM –æ–±—ä—è—Å–Ω—è–µ—Ç reasoning

        Returns:
            List[Dict]: –ü–æ–ª–Ω–æ—Å—Ç—å—é –≥–æ—Ç–æ–≤—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ –æ—Ç AI
        """

        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è LLM
        supports = key_levels.get("support", [])
        resistances = key_levels.get("resistance", [])
        atr = indicators.get("atr")
        atr_pct = indicators.get("atr_percent", 2.0)

        prompt = f"""–¢—ã –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ç—Ä–µ–π–¥–µ—Ä —Ñ—å—é—á–µ—Ä—Å–æ–≤ —Å 10+ –ª–µ—Ç –æ–ø—ã—Ç–∞. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π {symbol} –∏ —Å–æ–∑–¥–∞–π —Ç–æ—Ä–≥–æ–≤—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏.

üìä **–¢–ï–ö–£–©–ê–Ø –¶–ï–ù–ê**: ${current_price:.2f}

üìà **–†–´–ù–û–ß–ù–´–ô –ö–û–ù–¢–ï–ö–°–¢**:
- –¢—Ä–µ–Ω–¥: {market_context.get('trend', 'unknown')}
- Bias: {market_context.get('bias', 'neutral')} (strength: {market_context.get('strength', 0.5):.2f})
- Sentiment: {market_context.get('sentiment', 'unknown')}
- Volatility: {market_context.get('volatility', 'medium')}
- Phase: {market_context.get('phase', 'unknown')}

üìâ **–¢–ï–•–ù–ò–ß–ï–°–ö–ò–ï –ò–ù–î–ò–ö–ê–¢–û–†–´**:
- RSI: {indicators.get('rsi', 'N/A')}
- MACD: signal={indicators.get('macd_signal', 'N/A')}, histogram={indicators.get('macd_histogram', 'N/A')}
- EMA20: ${indicators.get('ema_20', 'N/A')}, EMA50: ${indicators.get('ema_50', 'N/A')}
- SMA200: ${indicators.get('sma_200', 'N/A')}
- ADX: {indicators.get('adx', 'N/A')} (trend strength)
- ATR: ${atr:.2f if atr else 'N/A'} ({atr_pct:.2f}% –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å)
- Bollinger Bands: middle ${indicators.get('bb_middle', 'N/A')}, upper ${indicators.get('bb_upper', 'N/A')}, lower ${indicators.get('bb_lower', 'N/A')}

üïØ **CANDLESTICK –ü–ê–¢–¢–ï–†–ù–´**:
{f"- Signal: {patterns.get('pattern_signal')}" if patterns else "- –ù–µ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤"}
{f"- Last pattern: {patterns.get('last_pattern')}" if patterns and patterns.get('last_pattern') else ""}
{f"- Pattern strength: {patterns.get('strength', 0):.2f}" if patterns else ""}

üéØ **KEY LEVELS**:
- Support levels: {', '.join([f'${s:.2f}' for s in supports[:5]]) if supports else 'None'}
- Resistance levels: {', '.join([f'${r:.2f}' for r in resistances[:5]]) if resistances else 'None'}

üí∞ **FUNDING & MARKET SENTIMENT**:
{f"- Funding rate: {funding.get('funding_rate_pct')}% (8h)" if funding else "- Funding: N/A"}
{f"- Long/Short ratio: {ls_ratio.get('long_short_ratio'):.2f}" if ls_ratio else "- L/S ratio: N/A"}
{f"- Longs: {ls_ratio.get('long_account'):.1f}%, Shorts: {ls_ratio.get('short_account'):.1f}%" if ls_ratio else ""}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

**–ó–ê–î–ê–ß–ê**: –°–æ–∑–¥–∞–π {max_scenarios + 2} —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤ (LONG –∏ SHORT) —Å –ü–û–õ–ù–´–ú –∞–Ω–∞–ª–∏–∑–æ–º.

**–î–õ–Ø –ö–ê–ñ–î–û–ì–û –°–¶–ï–ù–ê–†–ò–Ø –û–ü–†–ï–î–ï–õ–ò**:

1. **–¢–∏–ø —Å—Ü–µ–Ω–∞—Ä–∏—è**: Long Breakout? Short Rejection? Long Pullback? Short Breakdown? (–Ω–∞ –æ—Å–Ω–æ–≤–µ market context)

2. **Entry zone** (price_min, price_max):
   - –ì–¥–µ –ö–û–ù–ö–†–ï–¢–ù–û –≤—Ö–æ–¥–∏—Ç—å
   - –ü–æ—á–µ–º—É –∏–º–µ–Ω–Ω–æ —ç—Ç–∏ —É—Ä–æ–≤–Ω–∏ (–Ω–∞ –æ—Å–Ω–æ–≤–µ support/resistance)
   - –ê–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π –≤—Ö–æ–¥ vs –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω—ã–π –≤—Ö–æ–¥

3. **Stop Loss** (conservative, aggressive, recommended):
   - –ì–¥–µ INVALID–ê–¶–ò–Ø —Å—Ü–µ–Ω–∞—Ä–∏—è
   - –î–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞ –±–ª–∏–∂–∞–π—à–∏–º support/resistance
   - conservative = –¥–∞–ª—å—à–µ, aggressive = –±–ª–∏–∂–µ, recommended = –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π

4. **Targets** (TP1, TP2, TP3):
   - –ù–∞ –æ—Å–Ω–æ–≤–µ RESISTANCE/SUPPORT levels
   - TP1 = nearest resistance/support (~30% close)
   - TP2 = intermediate level (~40% close)
   - TP3 = major level (~30% close)
   - –†–∞—Å—Å—á–∏—Ç–∞–π Risk/Reward –¥–ª—è –∫–∞–∂–¥–æ–≥–æ target (reward / (entry_mid - recommended_stop))

5. **Confidence** (0.10 - 0.95):
   - –†–ï–ê–õ–¨–ù–ê–Ø –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —É—Å–ø–µ—Ö–∞ —ç—Ç–æ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è
   - –£—á–∏—Ç—ã–≤–∞–π –í–°–ï —Ñ–∞–∫—Ç–æ—Ä—ã –∏ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏—è!
   - –ï—Å–ª–∏ —Ç—Ä–µ–Ω–¥ –±—ã—á–∏–π + RSI 80 + funding –≤—ã—Å–æ–∫–∏–π = –ø–µ—Ä–µ–≥—Ä–µ–≤, SHORT –º–æ–∂–µ—Ç –±—ã—Ç—å –≤–µ—Ä–æ—è—Ç–Ω–µ–µ
   - PRIMARY —Å—Ü–µ–Ω–∞—Ä–∏–π (—Å–∞–º—ã–π –≤–µ—Ä–æ—è—Ç–Ω—ã–π): 65-85%
   - ALTERNATIVE —Å—Ü–µ–Ω–∞—Ä–∏–∏: 25-50%
   - UNLIKELY —Å—Ü–µ–Ω–∞—Ä–∏–∏: 10-25%

6. **Confidence factors**: –°–ø–∏—Å–æ–∫ –ø—Ä–∏—á–∏–Ω –ø–æ—á–µ–º—É —ç—Ç–∞ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å

7. **Risks**: –ö–∞–∫–∏–µ —Ä–∏—Å–∫–∏ –¥–ª—è —ç—Ç–æ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è

8. **Leverage recommendation**: 2x-3x (high vol), 3x-5x (medium), 5x-8x (low vol)

9. **Invalidation price**: –ì–¥–µ —Å—Ü–µ–Ω–∞—Ä–∏–π –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—Ç–º–µ–Ω—è–µ—Ç—Å—è

10. **Conditions**: –ß—Ç–æ –¥–æ–ª–∂–Ω–æ –ø—Ä–æ–∏–∑–æ–π—Ç–∏ –¥–ª—è –≤—Ö–æ–¥–∞

**–í–ê–ñ–ù–û**:
- –£—á–∏—Ç—ã–≤–∞–π –ü–†–û–¢–ò–í–û–†–ï–ß–ò–Ø (–±—ã—á–∏–π —Ç—Ä–µ–Ω–¥ + RSI 80 + funding 0.1% = –ø–µ—Ä–µ–≥—Ä–µ–≤!)
- Entry zones –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –õ–û–ì–ò–ß–ù–´–ú–ò (–Ω–∞ support/resistance, –Ω–µ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–µ!)
- Stop losses –∑–∞ key levels (–Ω–µ –≤ –≤–æ–∑–¥—É—Ö–µ!)
- Targets –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–µ resistance/support (–Ω–µ —Ñ–æ—Ä–º—É–ª—ã!)
- –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –¥–æ–ª–∂–Ω—ã –û–¢–†–ê–ñ–ê–¢–¨ –†–ï–ê–õ–¨–ù–û–°–¢–¨ (–Ω–µ –≤—Å–µ 60-65%!)

**–§–û–†–ú–ê–¢ –û–¢–í–ï–¢–ê** (—Å—Ç—Ä–æ–≥–æ JSON):
{{
  "scenarios": [
    {{
      "id": 1,
      "name": "Long Breakout",
      "bias": "long",
      "entry": {{
        "price_min": 96000,
        "price_max": 96500,
        "type": "limit_order",
        "reason": "Breakout above key resistance at $96k with volume confirmation"
      }},
      "stop_loss": {{
        "conservative": 94000,
        "aggressive": 94800,
        "recommended": 94500,
        "reason": "Below swing low and EMA20 support at $94.5k"
      }},
      "targets": [
        {{"level": 1, "price": 97800, "partial_close_pct": 30, "rr": 1.5, "reason": "First resistance zone"}},
        {{"level": 2, "price": 99500, "partial_close_pct": 40, "rr": 3.2, "reason": "Major resistance"}},
        {{"level": 3, "price": 102000, "partial_close_pct": 30, "rr": 5.5, "reason": "Round number $100k+"}}
      ],
      "confidence": 0.75,
      "confidence_factors": [
        "Strong bullish trend (price > EMA20 > EMA50)",
        "ADX 35 confirms trend strength",
        "Bullish pattern on 4h chart"
      ],
      "risks": [
        "Funding rate 0.08% shows overheated longs",
        "L/S ratio 2.3 indicates potential liquidation risk",
        "Resistance at $96k may reject price"
      ],
      "leverage": {{
        "recommended": "3x-5x",
        "max_safe": "7x",
        "reason": "Medium volatility (ATR 2.1%)"
      }},
      "invalidation_price": 94000,
      "conditions": [
        "Clean breakout above $96k on volume",
        "No bearish reversal patterns on lower timeframes",
        "Hold above EMA20 support"
      ]
    }},
    ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ ...
  ],
  "market_summary": "–ö—Ä–∞—Ç–∫–∏–π summary —Ä—ã–Ω–æ—á–Ω–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏ (2-3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è)",
  "primary_scenario_id": 1,
  "risk_level": "medium"
}}

**–û—Ç–≤–µ—á–∞–π –¢–û–õ–¨–ö–û JSON, –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞!**"""

        logger.debug(f"Sending market data to AI for scenario generation...")

        # JSON Schema –¥–ª—è –ì–ê–†–ê–ù–¢–ò–†–û–í–ê–ù–ù–û–ì–û –≤–∞–ª–∏–¥–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
        json_schema = {
            "name": "trading_scenarios",
            "schema": {
                "type": "object",
                "properties": {
                    "scenarios": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "id": {"type": "number"},
                                "name": {"type": "string"},
                                "bias": {"type": "string", "enum": ["long", "short"]},
                                "entry": {
                                    "type": "object",
                                    "properties": {
                                        "price_min": {"type": "number"},
                                        "price_max": {"type": "number"},
                                        "type": {"type": "string"},
                                        "reason": {"type": "string"}
                                    },
                                    "required": ["price_min", "price_max", "type", "reason"],
                                    "additionalProperties": False
                                },
                                "stop_loss": {
                                    "type": "object",
                                    "properties": {
                                        "conservative": {"type": "number"},
                                        "aggressive": {"type": "number"},
                                        "recommended": {"type": "number"},
                                        "reason": {"type": "string"}
                                    },
                                    "required": ["conservative", "aggressive", "recommended", "reason"],
                                    "additionalProperties": False
                                },
                                "targets": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "level": {"type": "number"},
                                            "price": {"type": "number"},
                                            "partial_close_pct": {"type": "number"},
                                            "rr": {"type": "number"},
                                            "reason": {"type": "string"}
                                        },
                                        "required": ["level", "price", "partial_close_pct", "rr", "reason"],
                                        "additionalProperties": False
                                    }
                                },
                                "confidence": {"type": "number", "minimum": 0.05, "maximum": 0.95},
                                "confidence_factors": {
                                    "type": "array",
                                    "items": {"type": "string"}
                                },
                                "risks": {
                                    "type": "array",
                                    "items": {"type": "string"}
                                },
                                "leverage": {
                                    "type": "object",
                                    "properties": {
                                        "recommended": {"type": "string"},
                                        "max_safe": {"type": "string"},
                                        "reason": {"type": "string"}
                                    },
                                    "required": ["recommended", "max_safe", "reason"],
                                    "additionalProperties": False
                                },
                                "invalidation_price": {"type": "number"},
                                "conditions": {
                                    "type": "array",
                                    "items": {"type": "string"}
                                }
                            },
                            "required": ["id", "name", "bias", "entry", "stop_loss", "targets", "confidence", "confidence_factors", "risks", "leverage", "invalidation_price", "conditions"],
                            "additionalProperties": False
                        }
                    },
                    "market_summary": {"type": "string"},
                    "primary_scenario_id": {"type": "number"},
                    "risk_level": {"type": "string", "enum": ["low", "medium", "high", "very_high"]}
                },
                "required": ["scenarios", "market_summary", "primary_scenario_id", "risk_level"],
                "additionalProperties": False
            },
            "strict": True
        }

        # üéØ –í—ã–∑—ã–≤–∞–µ–º LLM —Å –ì–ê–†–ê–ù–¢–ò–ï–ô –≤–∞–ª–∏–¥–Ω–æ–≥–æ JSON
        ai_result = await self.openai.structured_completion(
            prompt=prompt,
            json_schema=json_schema,
            model="gpt-4o",  # –¢–æ–ª—å–∫–æ gpt-4o/gpt-4o-mini –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç structured outputs
            temperature=0.4
        )

        scenarios = ai_result.get("scenarios", [])

        logger.info(f"ü§ñ AI Market Summary: {ai_result.get('market_summary', 'N/A')}")
        logger.info(f"ü§ñ AI generated {len(scenarios)} scenarios, primary: #{ai_result.get('primary_scenario_id')}")

        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ confidence
        scenarios = sorted(scenarios, key=lambda x: x["confidence"], reverse=True)

        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ (–º–∏–Ω–∏–º—É–º 3)
        return scenarios[:max(max_scenarios, 3)]

    # =========================================================================
    # üóëÔ∏è OLD RULE-BASED METHODS REMOVED (700+ lines)
    # =========================================================================
    # –£–¥–∞–ª–µ–Ω—ã –º–µ—Ç–æ–¥—ã:
    # - _ai_adjust_scenario_probabilities() - –Ω–µ –Ω—É–∂–µ–Ω, AI —Å—Ä–∞–∑—É –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏
    # - _rule_based_adjustment() - fallback –Ω–µ –Ω—É–∂–µ–Ω
    # - _generate_bullish_scenario() - –∑–∞–º–µ–Ω–µ–Ω –Ω–∞ AI-driven –≥–µ–Ω–µ—Ä–∞—Ü–∏—é
    # - _generate_bearish_scenario() - –∑–∞–º–µ–Ω–µ–Ω –Ω–∞ AI-driven –≥–µ–Ω–µ—Ä–∞—Ü–∏—é
    #
    # –¢–µ–ø–µ—Ä—å –≤—Å—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ _ai_generate_scenarios()
    # –∫–æ—Ç–æ—Ä—ã–π –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –í–°–ï –¥–∞–Ω–Ω—ã–µ –≤ LLM –∏ –ø–æ–ª—É—á–∞–µ—Ç –≥–æ—Ç–æ–≤—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏
    # =========================================================================
        """
        ü§ñ AI-DRIVEN: LLM –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –≤—Å–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ –∏ –≤—ã—Å—Ç–∞–≤–ª—è–µ—Ç —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–µ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏

        –í–º–µ—Å—Ç–æ –∂–µ—Å—Ç–∫–∏—Ö –ø—Ä–∞–≤–∏–ª "–µ—Å–ª–∏ X —Ç–æ +10%", LLM –≤–∏–¥–∏—Ç –ø–æ–ª–Ω—É—é –∫–∞—Ä—Ç–∏–Ω—É:
        - –ú–æ–∂–µ—Ç —É—á–µ—Å—Ç—å –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏—è (—Ç—Ä–µ–Ω–¥ –±—ã—á–∏–π, –Ω–æ RSI 80 + funding –≤—ã—Å–æ–∫–∏–π = –ø–µ—Ä–µ–≥—Ä–µ–≤)
        - –í—ã–±–∏—Ä–∞–µ—Ç PRIMARY —Å—Ü–µ–Ω–∞—Ä–∏–π (70-85%)
        - –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ (20-40%)
        - –ú–∞–ª–æ–≤–µ—Ä–æ—è—Ç–Ω—ã–µ (5-15%)
        """

        # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è LLM
        scenarios_summary = []
        for i, sc in enumerate(scenarios, 1):
            scenarios_summary.append({
                "index": i,
                "name": sc["name"],
                "bias": sc["bias"],
                "original_confidence": sc["confidence"],
                "entry": f"${sc['entry']['price_min']:.2f}-${sc['entry']['price_max']:.2f}",
                "stop": f"${sc['stop_loss']['recommended']:.2f}",
                "targets": [f"${t['price']:.2f} (RR {t['rr']:.1f})" for t in sc["targets"]],
            })

        prompt = f"""–¢—ã –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ç—Ä–µ–π–¥–µ—Ä-–∞–Ω–∞–ª–∏—Ç–∏–∫. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Ç–æ—Ä–≥–æ–≤—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ –¥–ª—è {symbol}.

üìä –¢–ï–ö–£–©–ê–Ø –¶–ï–ù–ê: ${current_price:.2f}

üìà –†–´–ù–û–ß–ù–´–ô –ö–û–ù–¢–ï–ö–°–¢:
- –¢—Ä–µ–Ω–¥: {market_context.get('trend', 'unknown')}
- Bias: {market_context.get('bias', 'neutral')} (strength: {market_context.get('strength', 0.5):.2f})
- Sentiment: {market_context.get('sentiment', 'unknown')}
- Volatility: {market_context.get('volatility', 'medium')}

üìâ –ò–ù–î–ò–ö–ê–¢–û–†–´:
- RSI: {indicators.get('rsi', 'N/A')}
- MACD: {indicators.get('macd_histogram', 'N/A')}
- EMA20: ${indicators.get('ema_20', 'N/A')}, EMA50: ${indicators.get('ema_50', 'N/A')}
- ADX: {indicators.get('adx', 'N/A')}

üïØ –ü–ê–¢–¢–ï–†–ù–´:
{f"- Signal: {patterns.get('pattern_signal')}" if patterns else "- –ù–µ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤"}
{f"- Last pattern: {patterns.get('last_pattern')}" if patterns and patterns.get('last_pattern') else ""}

üí∞ FUNDING & SENTIMENT:
{f"- Funding rate: {funding.get('funding_rate_pct')}%" if funding else "- Funding: N/A"}
{f"- Long/Short ratio: {ls_ratio.get('long_short_ratio'):.2f}" if ls_ratio else "- L/S ratio: N/A"}

üéØ –°–ì–ï–ù–ï–†–ò–†–û–í–ê–ù–ù–´–ï –°–¶–ï–ù–ê–†–ò–ò (—Å –±–∞–∑–æ–≤—ã–º–∏ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—è–º–∏):

{chr(10).join([f"{s['index']}. {s['name']} ({s['bias'].upper()}) - –±–∞–∑–æ–≤–∞—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å {s['original_confidence']:.0%}" +
    f"\\n   Entry: {s['entry']}, Stop: {s['stop']}" +
    f"\\n   Targets: {', '.join(s['targets'])}"
    for s in scenarios_summary])}

–ó–ê–î–ê–ß–ê:
–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –≤—Å–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ —Å —É—á–µ—Ç–æ–º –ü–û–õ–ù–û–ì–û –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Ä—ã–Ω–∫–∞ –∏ –≤—ã—Å—Ç–∞–≤–∏ –†–ï–ê–õ–ò–°–¢–ò–ß–ù–´–ï –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏:

1. –û–ø—Ä–µ–¥–µ–ª–∏ PRIMARY —Å—Ü–µ–Ω–∞—Ä–∏–π (–Ω–∞–∏–±–æ–ª–µ–µ –≤–µ—Ä–æ—è—Ç–Ω—ã–π): 65-85%
2. ALTERNATIVE —Å—Ü–µ–Ω–∞—Ä–∏–∏ (–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ): 20-45%
3. UNLIKELY —Å—Ü–µ–Ω–∞—Ä–∏–∏ (–º–∞–ª–æ–≤–µ—Ä–æ—è—Ç–Ω—ã–µ): 5-20%

–í–ê–ñ–ù–û:
- –£—á–∏—Ç—ã–≤–∞–π –ü–†–û–¢–ò–í–û–†–ï–ß–ò–Ø (–Ω–∞–ø—Ä–∏–º–µ—Ä: –±—ã—á–∏–π —Ç—Ä–µ–Ω–¥ + RSI 80 + –≤—ã—Å–æ–∫–∏–π funding = –ø–µ—Ä–µ–≥—Ä–µ–≤, SHORT –≤–µ—Ä–æ—è—Ç–Ω–µ–µ)
- –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –¥–æ–ª–∂–Ω—ã –æ—Ç—Ä–∞–∂–∞—Ç—å –†–ï–ê–õ–¨–ù–´–ô —Ä—ã–Ω–æ—á–Ω—ã–π bias
- –ï—Å–ª–∏ —Ç—Ä–µ–Ω–¥ —Å–∏–ª—å–Ω—ã–π –∏ –Ω–µ—Ç –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏–π - PRIMARY —Å—Ü–µ–Ω–∞—Ä–∏–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 75-85%
- –ï—Å–ª–∏ —Ä—ã–Ω–æ–∫ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π - –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –±–ª–∏–∂–µ –∫ 40-50%

–§–û–†–ú–ê–¢ –û–¢–í–ï–¢–ê (—Å—Ç—Ä–æ–≥–æ JSON):
{{
    "analysis": "–ö—Ä–∞—Ç–∫–∏–π –∞–Ω–∞–ª–∏–∑ –ø–æ—á–µ–º—É –≤—ã–±—Ä–∞–ª —Ç–∞–∫–∏–µ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ (2-3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è)",
    "probabilities": [
        {{"index": 1, "confidence": 0.75, "reason": "–ü–æ—á–µ–º—É –∏–º–µ–Ω–Ω–æ —ç—Ç–∞ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å"}},
        {{"index": 2, "confidence": 0.35, "reason": "..."}},
        ...
    ]
}}

–û—Ç–≤–µ—á–∞–π –¢–û–õ–¨–ö–û JSON, –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞!"""

        # –í—ã–∑—ã–≤–∞–µ–º LLM
        logger.debug(f"Sending {len(scenarios)} scenarios to AI for probability adjustment")

        response = await self.openai.simple_completion(
            prompt=prompt,
            model="gpt-4o-mini",  # –ò–ª–∏ "deepseek-chat" –µ—Å–ª–∏ —Ö–æ—á–µ—à—å –¥–µ—à–µ–≤–ª–µ
            temperature=0.3  # –ù–∏–∑–∫–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
        )

        # –ü–∞—Ä—Å–∏–º –æ—Ç–≤–µ—Ç
        try:
            # –£–±–∏—Ä–∞–µ–º markdown code blocks –µ—Å–ª–∏ –µ—Å—Ç—å
            clean_response = response.strip()
            if clean_response.startswith("```json"):
                clean_response = clean_response[7:]
            if clean_response.startswith("```"):
                clean_response = clean_response[3:]
            if clean_response.endswith("```"):
                clean_response = clean_response[:-3]

            ai_result = json.loads(clean_response.strip())

            logger.info(f"ü§ñ AI Analysis: {ai_result.get('analysis', 'No analysis')}")

            # –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–æ–≤—ã–µ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏
            for prob_data in ai_result.get("probabilities", []):
                idx = prob_data["index"] - 1  # 0-indexed
                if 0 <= idx < len(scenarios):
                    old_conf = scenarios[idx]["confidence"]
                    new_conf = prob_data["confidence"]

                    scenarios[idx]["confidence"] = round(new_conf, 2)

                    logger.debug(
                        f"  {scenarios[idx]['name']}: {old_conf:.2f} -> {new_conf:.2f} "
                        f"(reason: {prob_data.get('reason', 'N/A')})"
                    )

            return scenarios

        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse AI response as JSON: {e}")
            logger.error(f"Response was: {response}")
            raise

    def _rule_based_adjustment(
        self,
        scenarios: List[Dict],
        market_context: Dict
    ) -> List[Dict]:
        """
        Fallback: rule-based adjustment –µ—Å–ª–∏ AI –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª
        (–°—Ç–∞—Ä—ã–π –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –±—ã–ª —Ä–∞–Ω—å—à–µ)
        """
        market_bias = market_context.get("bias", "neutral")
        bias_strength = market_context.get("strength", 0.5)

        logger.debug(f"Using rule-based adjustment: bias={market_bias}, strength={bias_strength}")

        for scenario in scenarios:
            scenario_bias = scenario.get("bias")
            original_conf = scenario["confidence"]

            max_adjustment = 0.25 * bias_strength

            if market_bias == "long":
                adjustment = max_adjustment if scenario_bias == "long" else -max_adjustment
            elif market_bias == "short":
                adjustment = max_adjustment if scenario_bias == "short" else -max_adjustment
            else:
                adjustment = 0

            adjusted_conf = max(0.10, min(0.95, original_conf + adjustment))
            scenario["confidence"] = round(adjusted_conf, 2)

        return scenarios

    def _generate_bullish_scenario(
        self,
        symbol: str,
        current_price: float,
        market_context: Dict,
        indicators: Dict,
        key_levels: Dict,
        funding: Optional[Dict],
        ls_ratio: Optional[Dict],
        atr: Optional[float],
        atr_pct: float,
        entry_type: str = "breakout",  # üÜï breakout | pullback | support
        patterns: Optional[Dict] = None  # üîß –î–æ–±–∞–≤–ª–µ–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä patterns
    ) -> Dict[str, Any]:
        """Generate bullish trading scenario"""

        # === ENTRY ZONE (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç entry_type) ===
        supports = key_levels.get("support", [])
        resistances = key_levels.get("resistance", [])

        if entry_type == "breakout":
            # –ü—Ä–æ–±–æ–π –≤–≤–µ—Ä—Ö - –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π –≤—Ö–æ–¥ –≤—ã—à–µ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã
            entry_aggressive = current_price * 1.015  # 1.5% –≤—ã—à–µ
            entry_conservative = current_price * 1.005  # 0.5% –≤—ã—à–µ
            scenario_name = "Long Breakout"
            entry_reason = "Breakout above resistance"

        elif entry_type == "pullback":
            # –û—Ç–∫–∞—Ç –∫ –ø–æ–¥–¥–µ—Ä–∂–∫–µ - –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω—ã–π –≤—Ö–æ–¥ –Ω–∏–∂–µ
            entry_aggressive = current_price * 0.985  # 1.5% –Ω–∏–∂–µ
            entry_conservative = current_price * 0.975  # 2.5% –Ω–∏–∂–µ
            scenario_name = "Long Pullback"
            entry_reason = "Pullback to support zone"

        elif entry_type == "support":
            # –û—Ç—Å–∫–æ–∫ –æ—Ç —Å–∏–ª—å–Ω–æ–π –ø–æ–¥–¥–µ—Ä–∂–∫–∏
            valid_supports = [s for s in supports if s < current_price]
            if valid_supports:
                nearest_support = max(valid_supports)
                entry_aggressive = nearest_support * 1.005  # –ß—É—Ç—å –≤—ã—à–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏
                entry_conservative = nearest_support * 0.995  # –ù–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–µ
                scenario_name = "Long Support Bounce"
                entry_reason = f"Bounce from support at ${nearest_support:.2f}"
            else:
                # Fallback to pullback
                entry_aggressive = current_price * 0.985
                entry_conservative = current_price * 0.975
                scenario_name = "Long Support Bounce"
                entry_reason = "Support bounce entry"

        else:
            # Default: breakout
            entry_aggressive = current_price * 1.01
            entry_conservative = current_price * 0.98
            scenario_name = "Long"
            entry_reason = "Long entry"

        # üîß FIX: Calculate stop-loss RELATIVE TO ENTRY (not current_price!)
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ä–µ–¥–Ω—é—é —Ç–æ—á–∫—É –≤—Ö–æ–¥–∞ –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤
        entry_mid = (entry_aggressive + entry_conservative) / 2

        if atr:
            sl_conservative = entry_mid - (1.5 * atr)
            sl_aggressive = entry_mid - (1.0 * atr)
        else:
            sl_conservative = entry_mid * 0.95  # 5% below entry
            sl_aggressive = entry_mid * 0.97    # 3% below entry

        # Find nearest support for SL placement
        supports = key_levels.get("support", [])
        nearest_support = None
        if supports:
            valid_supports = [s for s in supports if s < entry_mid]
            if valid_supports:
                nearest_support = max(valid_supports)

        # üîß FIX: Calculate targets RELATIVE TO ENTRY (not current_price!)
        if atr:
            tp1 = entry_mid + (1.0 * atr)  # 1 ATR above entry
            tp2 = entry_mid + (2.0 * atr)  # 2 ATR above entry
            tp3 = entry_mid + (3.0 * atr)  # 3 ATR above entry
        else:
            tp1 = entry_mid * 1.03  # 3% above entry
            tp2 = entry_mid * 1.06  # 6% above entry
            tp3 = entry_mid * 1.09  # 9% above entry

        # Find resistances for targets
        resistances = key_levels.get("resistance", [])

        # üîß FIX: Calculate RR from RECOMMENDED stop (what bot shows!)
        # Recommended stop = nearest_support or sl_conservative
        recommended_stop = nearest_support if nearest_support else sl_conservative
        risk = abs(entry_mid - recommended_stop)  # Real risk shown to user

        if risk > 0:
            rr1 = abs(tp1 - entry_mid) / risk
            rr2 = abs(tp2 - entry_mid) / risk
            rr3 = abs(tp3 - entry_mid) / risk
        else:
            rr1 = rr2 = rr3 = 0

        # === CONFIDENCE CALCULATION ===
        confidence_factors = []
        confidence_score = 0.5  # Base

        # Trend alignment
        if market_context.get("trend") == "bullish":
            confidence_score += 0.15
            confidence_factors.append("Uptrend confirmed (EMA alignment)")

        # RSI oversold
        rsi = indicators.get("rsi", 50)
        if rsi and rsi < 40:
            confidence_score += 0.10
            confidence_factors.append(f"RSI {rsi:.1f} - oversold, bounce expected")

        # Funding negative (shorts overextended)
        if funding:
            funding_rate = funding.get("funding_rate_pct", 0)
            if funding_rate < -0.01:
                confidence_score += 0.10
                confidence_factors.append(f"Funding {funding_rate:.3f}% - shorts paying longs")

        # Long/Short ratio low (shorts dominance)
        if ls_ratio:
            ratio = ls_ratio.get("long_short_ratio", 1.0)
            if ratio < 0.8:
                confidence_score += 0.10
                confidence_factors.append(f"L/S ratio {ratio:.2f} - shorts dominant, potential squeeze")

        # üîß FIX: Bullish candlestick pattern check
        if patterns and patterns.get("pattern_signal") == "bullish":
            confidence_score += 0.15
            confidence_factors.append(f"Bullish pattern: {patterns.get('last_pattern')}")
        # üîß PENALTY: Bearish pattern –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏—Ç LONG!
        elif patterns and patterns.get("pattern_signal") == "bearish":
            confidence_score -= 0.15
            confidence_factors.append(f"‚ö†Ô∏è Bearish pattern detected: {patterns.get('last_pattern')} (–ø—Ä–æ—Ç–∏–≤ —Ç—Ä–µ–Ω–¥–∞)")

        # Clamp confidence at 0.1-0.95
        confidence_score = min(max(confidence_score, 0.1), 0.95)

        # === RISKS ===
        risks = []

        if market_context.get("trend") == "bearish":
            risks.append("Trading against trend (counter-trend)")

        if rsi and rsi > 70:
            risks.append(f"RSI {rsi:.1f} overbought - risk of pullback")

        # üîß FIX: Check resistance from ENTRY, not current_price!
        if resistances:
            nearest_resistance = min([r for r in resistances if r > entry_mid], default=None)
            if nearest_resistance:
                distance_pct = ((nearest_resistance - entry_mid) / entry_mid) * 100
                if distance_pct < 3:
                    risks.append(f"Close resistance at ${nearest_resistance:.2f} ({distance_pct:.1f}%)")

        # === LEVERAGE RECOMMENDATION ===
        if atr_pct < 2.0:
            leverage_rec = "5x-8x"
            max_safe = "10x"
        elif atr_pct < 4.0:
            leverage_rec = "3x-5x"
            max_safe = "7x"
        else:
            leverage_rec = "2x-3x"
            max_safe = "5x"

        # üîß FIX: Ensure price_min < price_max
        entry_min = min(entry_aggressive, entry_conservative)
        entry_max = max(entry_aggressive, entry_conservative)

        return {
            "id": 1,
            "name": scenario_name,  # üÜï –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –∏–º—è
            "bias": "long",
            "confidence": round(confidence_score, 2),
            "entry": {
                "price_min": round(entry_min, 2),
                "price_max": round(entry_max, 2),
                "type": "limit_order",
                "reason": entry_reason  # üÜï –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫—É—é –ø—Ä–∏—á–∏–Ω—É
            },
            "stop_loss": {
                "conservative": round(sl_conservative, 2),
                "aggressive": round(sl_aggressive, 2),
                "recommended": round(nearest_support, 2) if nearest_support else round(sl_conservative, 2),
                "reason": f"Below support at ${nearest_support:.2f}" if nearest_support else "ATR-based stop-loss"
            },
            "targets": [
                {
                    "level": 1,
                    "price": round(tp1, 2),
                    "partial_close_pct": 30,
                    "rr": round(rr1, 1),
                    "reason": "First resistance / 1 ATR target"
                },
                {
                    "level": 2,
                    "price": round(tp2, 2),
                    "partial_close_pct": 40,
                    "rr": round(rr2, 1),
                    "reason": "Major resistance / 2 ATR target"
                },
                {
                    "level": 3,
                    "price": round(tp3, 2),
                    "partial_close_pct": 30,
                    "rr": round(rr3, 1),
                    "reason": "Extended target / 3 ATR"
                }
            ],
            "leverage": {
                "recommended": leverage_rec,
                "max_safe": max_safe,
                "volatility_adjusted": True,
                "atr_pct": round(atr_pct, 2)
            },
            "invalidation": {
                "price": round(sl_conservative * 0.98, 2),
                "condition": "Break below major support with volume"
            },
            "why": {
                "bullish_factors": confidence_factors,
                "risks": risks if risks else ["None identified"]
            },
            "conditions": [
                f"Price holds above ${nearest_support:.2f}" if nearest_support else "Price holds current support",
                "Volume increases on upward moves",
                "No major bearish news"
            ]
        }

    def _generate_bearish_scenario(
        self,
        symbol: str,
        current_price: float,
        market_context: Dict,
        indicators: Dict,
        key_levels: Dict,
        funding: Optional[Dict],
        ls_ratio: Optional[Dict],
        atr: Optional[float],
        atr_pct: float,
        entry_type: str = "breakdown",  # üÜï breakdown | rejection | resistance
        patterns: Optional[Dict] = None  # üîß –î–æ–±–∞–≤–ª–µ–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä patterns
    ) -> Dict[str, Any]:
        """Generate bearish trading scenario"""

        # === ENTRY ZONE (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç entry_type) ===
        supports = key_levels.get("support", [])
        resistances = key_levels.get("resistance", [])

        if entry_type == "breakdown":
            # –ü—Ä–æ–±–æ–π –≤–Ω–∏–∑ - –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π –≤—Ö–æ–¥ –Ω–∏–∂–µ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã
            entry_aggressive = current_price * 0.985  # 1.5% –Ω–∏–∂–µ
            entry_conservative = current_price * 0.995  # 0.5% –Ω–∏–∂–µ
            scenario_name = "Short Breakdown"
            entry_reason = "Breakdown below support"

        elif entry_type == "rejection":
            # –û—Ç–±–æ–π –æ—Ç —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è - –≤—Ö–æ–¥ –≤—ã—à–µ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã
            entry_aggressive = current_price * 1.015  # 1.5% –≤—ã—à–µ
            entry_conservative = current_price * 1.005  # 0.5% –≤—ã—à–µ
            scenario_name = "Short Rejection"
            entry_reason = "Rejection from resistance"

        elif entry_type == "resistance":
            # –í—Ö–æ–¥ –æ—Ç —Å–∏–ª—å–Ω–æ–≥–æ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è
            valid_resistances = [r for r in resistances if r > current_price]
            if valid_resistances:
                nearest_resistance = min(valid_resistances)
                entry_aggressive = nearest_resistance * 0.995  # –ß—É—Ç—å –Ω–∏–∂–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è
                entry_conservative = nearest_resistance * 1.005  # –ù–∞ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–∏
                scenario_name = "Short Resistance"
                entry_reason = f"Rejection from resistance at ${nearest_resistance:.2f}"
            else:
                # Fallback to rejection
                entry_aggressive = current_price * 1.015
                entry_conservative = current_price * 1.005
                scenario_name = "Short Resistance"
                entry_reason = "Resistance rejection entry"

        else:
            # Default: breakdown
            entry_aggressive = current_price * 0.99
            entry_conservative = current_price * 1.02
            scenario_name = "Short"
            entry_reason = "Short entry"

        # üîß FIX: Calculate stop-loss RELATIVE TO ENTRY (not current_price!)
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ä–µ–¥–Ω—é—é —Ç–æ—á–∫—É –≤—Ö–æ–¥–∞ –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤
        entry_mid = (entry_aggressive + entry_conservative) / 2

        if atr:
            sl_conservative = entry_mid + (1.5 * atr)
            sl_aggressive = entry_mid + (1.0 * atr)
        else:
            sl_conservative = entry_mid * 1.05  # 5% above entry
            sl_aggressive = entry_mid * 1.03    # 3% above entry

        # Find nearest resistance for SL
        resistances = key_levels.get("resistance", [])
        nearest_resistance = None
        if resistances:
            valid_resistances = [r for r in resistances if r > entry_mid]
            if valid_resistances:
                nearest_resistance = min(valid_resistances)

        # üîß FIX: Calculate targets RELATIVE TO ENTRY (not current_price!)
        if atr:
            tp1 = entry_mid - (1.0 * atr)
            tp2 = entry_mid - (2.0 * atr)
            tp3 = entry_mid - (3.0 * atr)
        else:
            tp1 = entry_mid * 0.97   # 3% below entry
            tp2 = entry_mid * 0.94   # 6% below entry
            tp3 = entry_mid * 0.91   # 9% below entry

        # üîß FIX: Calculate RR from RECOMMENDED stop (what bot shows!)
        # Recommended stop = nearest_resistance or sl_conservative
        recommended_stop = nearest_resistance if nearest_resistance else sl_conservative
        risk = abs(recommended_stop - entry_mid)  # Real risk shown to user

        if risk > 0:
            rr1 = abs(entry_mid - tp1) / risk  # Entry ‚Üí TP1
            rr2 = abs(entry_mid - tp2) / risk  # Entry ‚Üí TP2
            rr3 = abs(entry_mid - tp3) / risk  # Entry ‚Üí TP3
        else:
            rr1 = rr2 = rr3 = 0

        # === CONFIDENCE CALCULATION ===
        confidence_factors = []
        confidence_score = 0.5

        if market_context.get("trend") == "bearish":
            confidence_score += 0.15
            confidence_factors.append("Downtrend confirmed")

        rsi = indicators.get("rsi", 50)
        if rsi and rsi > 60:
            confidence_score += 0.10
            confidence_factors.append(f"RSI {rsi:.1f} - overbought")

        if funding:
            funding_rate = funding.get("funding_rate_pct", 0)
            if funding_rate > 0.01:
                confidence_score += 0.10
                confidence_factors.append(f"Funding {funding_rate:.3f}% - longs overextended")

        if ls_ratio:
            ratio = ls_ratio.get("long_short_ratio", 1.0)
            if ratio > 1.5:
                confidence_score += 0.10
                confidence_factors.append(f"L/S ratio {ratio:.2f} - longs dominant, potential liquidation cascade")

        # üîß FIX: Bearish candlestick pattern check
        if patterns and patterns.get("pattern_signal") == "bearish":
            confidence_score += 0.10
            confidence_factors.append(f"Bearish pattern: {patterns.get('last_pattern')}")
        # üîß PENALTY: Bullish pattern –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏—Ç SHORT!
        elif patterns and patterns.get("pattern_signal") == "bullish":
            confidence_score -= 0.15
            confidence_factors.append(f"‚ö†Ô∏è Bullish pattern detected: {patterns.get('last_pattern')} (–ø—Ä–æ—Ç–∏–≤ —Ç—Ä–µ–Ω–¥–∞)")

        confidence_score = min(max(confidence_score, 0.1), 0.95)  # Clamp 0.1-0.95

        # === RISKS ===
        risks = []
        if market_context.get("trend") == "bullish":
            risks.append("Trading against trend")

        if rsi and rsi < 30:
            risks.append(f"RSI {rsi:.1f} oversold - bounce risk")

        # üîß FIX: Check support from ENTRY, not current_price!
        if supports:
            nearest_support_risk = max([s for s in supports if s < entry_mid], default=None)
            if nearest_support_risk:
                distance_pct = ((entry_mid - nearest_support_risk) / entry_mid) * 100
                if distance_pct < 3:
                    risks.append(f"Close support at ${nearest_support_risk:.2f} ({distance_pct:.1f}%)")

        # Leverage
        if atr_pct < 2.0:
            leverage_rec = "5x-8x"
            max_safe = "10x"
        elif atr_pct < 4.0:
            leverage_rec = "3x-5x"
            max_safe = "7x"
        else:
            leverage_rec = "2x-3x"
            max_safe = "5x"

        # üîß FIX: Ensure price_min < price_max
        entry_min = min(entry_aggressive, entry_conservative)
        entry_max = max(entry_aggressive, entry_conservative)

        return {
            "id": 2,
            "name": scenario_name,  # üÜï –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –∏–º—è
            "bias": "short",
            "confidence": round(confidence_score, 2),
            "entry": {
                "price_min": round(entry_min, 2),
                "price_max": round(entry_max, 2),
                "type": "limit_order",
                "reason": entry_reason  # üÜï –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫—É—é –ø—Ä–∏—á–∏–Ω—É
            },
            "stop_loss": {
                "conservative": round(sl_conservative, 2),
                "aggressive": round(sl_aggressive, 2),
                "recommended": round(nearest_resistance, 2) if nearest_resistance else round(sl_conservative, 2),
                "reason": f"Above resistance at ${nearest_resistance:.2f}" if nearest_resistance else "ATR-based stop"
            },
            "targets": [
                {
                    "level": 1,
                    "price": round(tp1, 2),
                    "partial_close_pct": 30,
                    "rr": round(rr1, 1),
                    "reason": "First support / 1 ATR target"
                },
                {
                    "level": 2,
                    "price": round(tp2, 2),
                    "partial_close_pct": 40,
                    "rr": round(rr2, 1),
                    "reason": "Major support / 2 ATR target"
                },
                {
                    "level": 3,
                    "price": round(tp3, 2),
                    "partial_close_pct": 30,
                    "rr": round(rr3, 1),
                    "reason": "Extended target / 3 ATR"
                }
            ],
            "leverage": {
                "recommended": leverage_rec,
                "max_safe": max_safe,
                "volatility_adjusted": True,
                "atr_pct": round(atr_pct, 2)
            },
            "invalidation": {
                "price": round(sl_conservative * 1.02, 2),
                "condition": "Break above resistance with volume"
            },
            "why": {
                "bearish_factors": confidence_factors,
                "risks": risks if risks else ["None identified"]
            },
            "conditions": [
                f"Price fails to break ${nearest_resistance:.2f}" if nearest_resistance else "Price rejects resistance",
                "Volume increases on downward moves",
                "No major bullish catalysts"
            ]
        }

    def _generate_range_scenario(
        self,
        symbol: str,
        current_price: float,
        market_context: Dict,
        key_levels: Dict,
        atr: Optional[float]
    ) -> Dict[str, Any]:
        """Generate range-bound trading scenario"""

        supports = key_levels.get("support", [])
        resistances = key_levels.get("resistance", [])

        # Find range boundaries
        if supports and resistances:
            range_low = max([s for s in supports if s < current_price], default=current_price * 0.95)
            range_high = min([r for r in resistances if r > current_price], default=current_price * 1.05)
        else:
            range_low = current_price * 0.95
            range_high = current_price * 1.05

        range_mid = (range_low + range_high) / 2

        return {
            "id": 3,
            "name": "Range Trading",
            "bias": "neutral",
            "confidence": 0.60,
            "strategy": {
                "type": "range_bound",
                "range_low": round(range_low, 2),
                "range_high": round(range_high, 2),
                "range_mid": round(range_mid, 2)
            },
            "trades": [
                {
                    "type": "long",
                    "entry": round(range_low * 1.01, 2),
                    "target": round(range_mid, 2),
                    "stop": round(range_low * 0.98, 2)
                },
                {
                    "type": "short",
                    "entry": round(range_high * 0.99, 2),
                    "target": round(range_mid, 2),
                    "stop": round(range_high * 1.02, 2)
                }
            ],
            "leverage": {
                "recommended": "3x-5x",
                "max_safe": "7x",
                "volatility_adjusted": True
            },
            "why": {
                "factors": [
                    "Market in consolidation phase",
                    "No clear directional bias",
                    "Price respecting range boundaries"
                ],
                "risks": [
                    "Breakout risk - range can break anytime",
                    "False breakouts common in low volatility"
                ]
            },
            "conditions": [
                f"Price stays between ${range_low:.2f} - ${range_high:.2f}",
                "Low volatility environment",
                "No major news expected"
            ]
        }

    def _assess_data_quality(
        self,
        klines: pd.DataFrame,
        indicators: Dict,
        funding: Optional[Dict],
        oi: Optional[Dict],
        liquidation_data: Optional[Dict]
    ) -> Dict[str, Any]:
        """
        –û—Ü–µ–Ω–∏—Ç—å –∫–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞

        Returns:
            {
                "completeness": 0-100,
                "sources": [...],
                "warnings": [...]
            }
        """
        completeness = 0
        sources = []
        warnings = []

        # Klines data
        if klines is not None and len(klines) >= 100:
            completeness += 25
            sources.append("candlestick_data")
        else:
            warnings.append("Insufficient candlestick data")

        # Technical indicators
        if indicators and len(indicators) >= 10:
            completeness += 25
            sources.append("technical_indicators")
        else:
            warnings.append("Limited technical indicators")

        # Funding rate
        if funding:
            completeness += 20
            sources.append("funding_rates")
        else:
            warnings.append("Funding rate unavailable")

        # Open Interest
        if oi:
            completeness += 15
            sources.append("open_interest")
        else:
            warnings.append("Open Interest unavailable")

        # Liquidation data
        if liquidation_data and liquidation_data.get("total_liquidations", 0) > 0:
            completeness += 15
            sources.append("liquidation_history")
        else:
            warnings.append("Liquidation data unavailable (requires API keys)")

        return {
            "completeness": completeness,
            "sources": sources,
            "warnings": warnings if warnings else None
        }


# Singleton instance
futures_analysis_service = FuturesAnalysisService()
